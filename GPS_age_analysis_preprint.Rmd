---
title: "GPS_age"
author: "Jo Cutler & Paul Vanags"
date: "07/06/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

options(digits = 4)

# load required packages and functions

require(pacman)
pacman::p_load(car,
               cowplot,
               countrycode,
               effectsize,
               factoextra,
               ggridges,
               ggtext,
               GPArotation,
               gridExtra,
               haven,
               Hmisc,
               hrbrthemes,
               irr,
               jtools,
               kableExtra,
               lavaan,
               lemon,
               lme4, 
               lmerTest,
               mediation,
               nFactors,
               parameters, 
               psych,
               rstudioapi,
               scales,
               see,
               tidyquant,
               tidyverse,
               viridis
)

### Function to format p values taken from https://stackoverflow.com/questions/23018256/printing-p-values-with-0-001

## version without = sign
pvalr <- function(pvals, sig.limit = .001, digits = 3, html = FALSE) {
  
  roundr <- function(x, digits = 1) {
    res <- sprintf(paste0('%.', digits, 'f'), x)
    zzz <- paste0('0.', paste(rep('0', digits), collapse = ''))
    res[res == paste0('-', zzz)] <- zzz
    res
  }
  
  sapply(pvals, function(x, sig.limit) {
    if (x < sig.limit)
      if (html)
        return(sprintf('&lt; %s', format(sig.limit))) else
          return(sprintf('<%s', format(sig.limit)))
    if (x > .1)
      return(roundr(x, digits = 2)) else
        return(roundr(x, digits = digits))
  }, sig.limit = sig.limit)
}

# Get the name of the directory in which the current file is located.
cur_dir = dirname(getSourceEditorContext()$path)

# Change the working directory to the directory with the current file.
setwd(cur_dir)

```

## Data wrangle

```{r data-prep, echo = FALSE, include=FALSE}

df <- read_dta("data/Gallup_short.dta") 
df <- df %>% 
  subset(age < 74) 

df <- df %>% 
  mutate(gender = factor(gender,
                         levels = c(0,1),
                         labels = c("Male", "Female"))) %>% 
  add_column(id = 1:nrow(df))

contrasts(df$gender) <- contr.sum(length(levels(df$gender)))

df$age.r <- df$age
df$age <- scale(df$age)
df$subj_math_skills.r <- df$subj_math_skills
df$subj_math_skills <- scale(df$subj_math_skills)

resolution <- 300
plotW <- 4
plotH <- 4

axtext <- 16
axtitle <- 20
dotcols <- c("#A363D9")
pos.corr.col <- "#CA4640" 
neg.corr.col <-  "#00A7DD"

prefs <- c("prosocial_contrib", "negrecip", "posrecip", "altruism", "trust")
pref.labs <- c("Prosociality", "Negative reciprocity", "Positive reciprocity", "Altruism", "Trust")
behavs <- c("WP108", "WP109", "WP110")
behav.labs <- c("Donating money", "Volunteering", "Helping a stranger")

#add continent names to df
df$continent <- countrycode(df$country, 'country.name', 'region')

#Add gni data
gni <- readxl::read_xlsx("data/GNI.xlsx") %>%
  rename("isocode" = "Country Code") %>%
  rename("gni" = "2018GNI") %>%
  mutate(gni = scale(gni)) %>%
  mutate(IncomeGroup = factor(IncomeGroup, levels = c("Low income", "Lower middle income", "Upper middle income", "High income"), ordered = T))

df <- left_join(df, gni, by = "isocode")

# OECD allocation (from Gender file)
world.bank <- read.csv("data/Data_Extract_From_World_Development_Indicators/5f01a212-b834-4098-aa44-7c7bdc81428f_Data.csv", na.strings = "..", fileEncoding = 'UTF-8-BOM') %>% # NB. fileEncoding prevents i.. on 1st column name
  rename("isocode" = "Country.Code")

gdp <- world.bank %>%
  subset(Series.Code == "NY.GDP.PCAP.CD") %>% 
  rename("gdp" = "X2012..YR2012.") 

gdp <- semi_join(x = gdp, y = df, by = "isocode") %>%
  mutate(gdp.quart = ntile(gdp, 4)) %>%
  mutate(gdp = scale(gdp))

le <- world.bank %>% 
  subset(str_detect(Series.Name, "Life expectancy at birth")) %>% 
  rename("life.exp" = "X2012..YR2012.") %>% 
  pivot_wider(id_cols = c("Country.Name", "isocode"), names_from = "Series.Name", values_from = "life.exp")

colnames(le) <- gsub("Life expectancy at birth, ", "le.", colnames(le))
colnames(le) <- gsub(" ", ".", colnames(le))

df <- left_join(df, gdp, by = "isocode")
df <- left_join(df, le, by = "isocode")

# OECD or not?
oecd <- c("Austria", "Australia", "Belgium", "Canada", "Chile", "Colombia", "Costa Rica", "Czech Republic", "Denmark", "Estonia", "Finland", "France", "Germany", "Greece", "Hungary", "Iceland", "Ireland", "Israel", "Italy", "Japan", "Korea", "Latvia", "Lithuania", "Luxembourg", "Mexico", "the Netherlands", "New Zealand", "Norway", "Poland", "Portugal", "Slovak Republic", "Slovenia", "Spain", "Sweden", "Switzerland", "Turkey", "the United Kingdom", "United States") # from https://www.oecd.org/newsroom/oecd-welcomes-costa-rica-as-its-38th-member.htm

oecd.isocode <- countrycode(oecd, 'country.name', 'iso3c')

# add adjusted age and OECD index to main dataframe

# df$age.adj <- NA
# df$oecd <- NA
# 
# for (r in 1:nrow(df)) {
#   if (is.na(df$isocode[r])) {
#     df$oecd[r] <- 0
#   } else {
#     if (sum(str_detect(oecd.isocode, df$isocode[r])) == 0) {
#       df$oecd[r] <- 0
#     } else if (sum(str_detect(oecd.isocode, df$isocode[r])) == 1) {
#       df$oecd[r] <- 1
#     } else {stop('not found 1 or 0 matches')}
#   }
#   
#   if(df$gender[r] == "Male") {
#     df$age.adj[r] <- df$age.r[r] / df$`le.male.(years)`[r]
#   } else if (df$gender[r] == "Female") {
#     df$age.adj[r] <- df$age.r[r] / df$`le.female.(years)`[r]
#   }
# }
# 
# df$oecd <- factor(df$oecd, levels = c(1,0), labels = c("oecd", "not oecd"))
# 
# df$age.adj.z <- scale(df$age.adj)

```

## Calculate indices

```{r indices, echo=FALSE, include=FALSE}

# financial wellbeing

# For WP2319, respondents who say they are “living comfortably on present income” 
# are recoded as “1,” and all other answers are recoded as “0.”
# WP2319: 1 = living comfortably, 2-6 = other response

df$WP2319_raw <- df$WP2319
df$WP2319 <- 0
df$WP2319[df$WP2319_raw == 1] <- 1
df$WP2319[is.na(df$WP2319_raw)] <- NA

# The remaining four items are recoded so that positive answers are scored as a “1” 
# and all other answers (including don’t know and refused) are assigned a score of “0.”
# WP30: 1 = satisfied, 2-4 = other response
# WP31: 1 = getting better, 2-4 = other response
# WP88: 1 = getting better, 2-5 = other response

df$WP30_raw <- df$WP30
df$WP30 <- 0
df$WP30[df$WP30_raw == 1] <- 1
df$WP30[is.na(df$WP30_raw)] <- NA
df$WP31_raw <- df$WP31
df$WP31 <- 0
df$WP31[df$WP31_raw == 1] <- 1
df$WP31[is.na(df$WP31_raw)] <- NA
df$WP88_raw <- df$WP88
df$WP88 <- 0
df$WP88[df$WP88_raw == 1] <- 1
df$WP88[is.na(df$WP88_raw)] <- NA

# An individual record has an index calculated if it has valid scores for WP2319 and valid scores from at
# least three of the other four index questions. A record’s final index score is the average of the mean 
# for responses to WP2319 and the mean of the three other items multiplied by 100.

# TODO - says 3 of 4 other index questions but only 3 others - assumed at least 2 of 3 but check?

df <- df %>% 
  mutate(WP30_31_88 = select(., c("WP30", "WP31", "WP88")) %>% rowMeans(na.rm = T)) %>% 
  mutate(WP30_31_88_count = rowSums(!is.na(df %>% select("WP30", "WP31", "WP88"))))
df$WP30_31_88[df$WP30_31_88_count < 2] <- NA

df <- df %>% 
  mutate(financial_wellbeing = select(., c("WP30_31_88", "WP2319")) %>% rowMeans(na.rm = T) * 100) %>% 
  mutate(WP2319_303188_count = rowSums(!is.na(df %>% select("WP30_31_88", "WP2319"))))
df$financial_wellbeing[df$WP2319_303188_count < 2] <- NA

df$financial_wellbeing.r <- df$financial_wellbeing
df$financial_wellbeing <- scale(df$financial_wellbeing)

# physical wellbeing

# all items are recoded so that favorable answers are scored as a “1” and all other answers 
# (including don’t know and refused) are assigned a score of “0.”
# WP23: health problem? 2 = favourable (no) 1,3&4 = other response
# WP60: well-rested? 1 = favourable (yes) 2-4 = other response
# WP68: physical pain? 2 = favourable (no) 1,3&4 = other response
# WP69: worry? 2 = favourable (no) 1,3&4 = other response
# WP70: sadness? 2 = favourable (no) 1,3&4 = other response

df$WP23_raw <- df$WP23
df$WP23 <- 0
df$WP23[df$WP23_raw == 2] <- 1
df$WP23[is.na(df$WP23_raw)] <- NA
df$WP60_raw <- df$WP60
df$WP60 <- 0
df$WP60[df$WP60_raw == 1] <- 1
df$WP60[is.na(df$WP60_raw)] <- NA
df$WP68_raw <- df$WP68
df$WP68 <- 0
df$WP68[df$WP68_raw == 2] <- 1
df$WP68[is.na(df$WP68_raw)] <- NA
df$WP69_raw <- df$WP69
df$WP69 <- 0
df$WP69[df$WP69_raw == 2] <- 1
df$WP69[is.na(df$WP69_raw)] <- NA
df$WP70_raw <- df$WP70
df$WP70 <- 0
df$WP70[df$WP70_raw == 2] <- 1
df$WP70[is.na(df$WP70_raw)] <- NA

# Respondents must have answered at least four questions for an individual index to be calculated.
# A record’s final index score is the mean of valid items multiplied by 100.

df <- df %>% 
  mutate(physical_wellbeing = select(., c("WP23", "WP60", "WP68", "WP69", "WP70")) %>% rowMeans(na.rm = T) * 100) %>% 
  mutate(WP23_60_68_69_70_count = rowSums(!is.na(df %>% select("WP23", "WP60", "WP68", "WP69", "WP70"))))
df$physical_wellbeing[df$WP23_60_68_69_70_count < 4] <- NA

df$physical_wellbeing.r <- df$physical_wellbeing
df$physical_wellbeing <- scale(df$physical_wellbeing)

# prosocial behaviours
# WP108: donated? 1 = yes, 2-4 = other response
# WP109: volunteered? 1 = yes, 2-4 = other response
# WP110: helped? 1 = yes, 2-4 = other response

df$WP108_raw <- df$WP108
df$WP108 <- 0
df$WP108[df$WP108_raw == 1] <- 1
df$WP108[is.na(df$WP108_raw)] <- NA
df$WP109_raw <- df$WP109
df$WP109 <- 0
df$WP109[df$WP109_raw == 1] <- 1
df$WP109[is.na(df$WP109_raw)] <- NA
df$WP110_raw <- df$WP110
df$WP110 <- 0
df$WP110[df$WP110_raw == 1] <- 1
df$WP110[is.na(df$WP110_raw)] <- NA

```

## PCA

```{r pca, echo=FALSE, include=FALSE}

# TODO get this to precisely match Fabians?

# without weighting, with neg reciprocity
df.dropna <- df %>% drop_na(c("posrecip", "negrecip", "altruism", "trust")) %>% 
  select(posrecip, negrecip, altruism, trust)

cor(df.dropna[,c("posrecip", "negrecip", "altruism", "trust")])

dat.pca <- prcomp(df.dropna[,c("posrecip", "negrecip", "altruism", "trust")], scale = TRUE)

summary(dat.pca)

fviz_eig(dat.pca)

fviz_pca_var(dat.pca,
             col.var = "contrib", # Color by contributions to the PC
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE     # Avoid text overlapping
)

get_eigenvalue(dat.pca)

#without weighting, without neg reciprocity

cor(df.dropna[,c("posrecip", "altruism", "trust")])

dat.pca <- prcomp(df.dropna[,c("posrecip", "altruism", "trust")], scale = TRUE)

summary(dat.pca)

fviz_eig(dat.pca)

fviz_pca_var(dat.pca,
             col.var = "contrib", # Color by contributions to the PC
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE     # Avoid text overlapping
)

get_eigenvalue(dat.pca)

#loadings of variable on each component
dat.pca$rotation

dat.var <- get_pca_var(dat.pca)
dat.var$contrib        # Contributions to the Principal Component

# Create new prosociality composite based on CONTRIBUTION weighting
df$prosocial_contrib <- scale(dat.var$contrib["posrecip",1]*df$posrecip + 
                                dat.var$contrib["altruism",1]*df$altruism + 
                                dat.var$contrib["trust",1]*df$trust)

# Create new prosociality composite based on COMPONENT LOADING weighting
df$prosocial_load <- scale(dat.pca$rotation["posrecip",1]*df$posrecip + 
                             dat.pca$rotation["altruism",1]*df$altruism + 
                             dat.pca$rotation["trust",1]*df$trust) * -1

#create weighted prosociliaty measures
df$prosocial_wgt_c <- df$prosocial_contrib * df$wgt
df$prosocial_wgt_l <- df$prosocial_load * df$wgt

```

## DESCRIPTIVES + Data VISUALISATION

```{r descriptives, eval = TRUE, echo=FALSE, warning=FALSE, message=FALSE}

#sum((df$gender) == "Male")
#sum((df$gender) == "Female")

#summary descriptives
desc_stats <- df %>% select(c("subj_math_skills.r", "age.r", "financial_wellbeing.r", "physical_wellbeing.r", "trust",
                     "altruism", "posrecip", "negrecip", "WP108", "WP109", "WP110"))
describe(desc_stats, skew = FALSE, quant = 0.5) %>% kbl(digits = 2, format = "html") %>% save_kable("descriptives.html")


# Histogram of age distribution
df %>% ggplot(aes(x = age.r)) + geom_histogram(colour="black", fill="grey", binwidth = 1) + xlab("Age") + ylab("Count") + geom_vline(xintercept = 39.9, linetype="dashed") + 
  annotate(geom = "text", x = 40, y = 2500, label = "mean", hjust = -0.1) +
  scale_x_continuous(breaks = seq(15, 73, by = 5))  + theme_apa() 

# Histogram of age distribution Positive Reciprocity
p1 <- df %>% ggplot(aes(x = posrecip)) + geom_histogram(colour="black", fill="grey", binwidth = 0.1) + xlab("Positive reciprocity") + ylab("Count") + theme_apa()

# Histogram of age distribution Negative Reciprocity
p2 <- df %>% ggplot(aes(x = negrecip)) + geom_histogram(colour="black", fill="grey", binwidth = 0.1) + xlab("Negative Reciprocity") + ylab("Count") + theme_apa() 

# Histogram of age distribution Altruism
p3 <- df %>% ggplot(aes(x = altruism)) + geom_histogram(colour="black", fill="grey", binwidth = 0.1) + xlab("Altruism") + ylab("Count") + theme_apa() 

# Histogram of age distribution Trust
p4 <- df %>% ggplot(aes(x = trust)) + geom_histogram(colour="black", fill="grey", binwidth = 0.1) + xlab("Trust") + ylab("Count") + theme_apa() 

d <- grid.arrange(p1, p2, p3, p4)


# Boxplot of age distribution by country
ggplot(df, aes(x=reorder(country, age.r, na.rm = TRUE), y=age.r)) + geom_boxplot() + ylab("Age") + xlab("") +
  theme(axis.text.x = element_text(angle = 90, vjust = 0.5, hjust=1, size = 7), axis.line.x = element_line(colour = "black")) + 
  theme(panel.background = element_blank(), panel.grid.major.y = element_line(color = "grey"))

#scatter plots
#define function

scatter_plot <- function(x, y) {
  df %>% ggplot(aes(x = x, y = y, group = country)) + 
    geom_point(
        color="#69b3a2",
        fill="#69b3a2",
        shape=21,
        alpha=0.01,
        size=3,
        stroke = 1) +
    theme_apa() +
    geom_smooth(method='lm', formula= y ~ x, size = 0.5, se = F, linetype = "longdash") 
}

scatter_plot(df$age.r, df$prosocial_contrib) + ylab("Prosociality")
scatter_plot(df$age.r, df$posrecip) + ylab("Positive Reciprocity")
scatter_plot(df$age.r, df$altruism) + ylab("Altruism")
scatter_plot(df$age.r, df$negrecip) + ylab("Negative Reciprocity")

#Distributions of control variables
df %>% ggplot(aes(x = financial_wellbeing)) + geom_histogram(colour="black", fill="grey", binwidth = 0.1) + xlab("Age") + ylab("Financial well-being") + theme_apa() 
df %>% ggplot(aes(x = physical_wellbeing)) + geom_histogram(colour="black", fill="grey", binwidth = 0.1) + xlab("Age") + ylab("Physical well-being") + theme_apa() 
df %>% ggplot(aes(x = subj_math_skills)) + geom_histogram(colour="black", fill="grey", binwidth = 0.1) + xlab("Age") + ylab("Subjective Maths skills") + theme_apa() 


#create numerical index for gender
df$gender_index <- as.integer(df$gender)

# Correlation matrix of control variables and DV's
c1 <- df %>% select(age, financial_wellbeing, physical_wellbeing, subj_math_skills, posrecip, negrecip, altruism, trust, WP108_raw, WP109_raw, WP110_raw, gender_index, prosocial_contrib) %>% cor(use = "complete.obs")
colnames(c1) <- c("Age", "Financial well-being", "Physical well-being", "Subjective Maths skills", "Positive Reciprocity", "Negative Reciprocity", "Altruism", "Trust", "Donated money", "Volunteered", "Helped a stranger", "Gender", "Prosocial composite")
rownames(c1) <- c("Age", "Financial well-being", "Physical well-being", "Subjective Maths skills", "Positive Reciprocity", "Negative Reciprocity", "Altruism", "Trust", "Donated money", "Volunteered", "Helped a stranger", "Gender", "Prosocial composite")

# Function to create matrix of p-values to add significance data to correlation matrix
cor.mtest <- function(mat, ...) {
    mat <- as.matrix(mat)
    n <- ncol(mat)
    p.mat<- matrix(NA, n, n)
    diag(p.mat) <- 0
    for (i in 1:(n - 1)) {
        for (j in (i + 1):n) {
            tmp <- cor.test(mat[, i], mat[, j], ...)
            p.mat[i, j] <- p.mat[j, i] <- tmp$p.value
        }
    }
  colnames(p.mat) <- rownames(p.mat) <- colnames(mat)
  p.mat
}

# matrix of the p-value of the correlation with matched column and row names
p.mat <- cor.mtest(df %>% select(age, financial_wellbeing, physical_wellbeing, subj_math_skills, posrecip, negrecip, altruism, trust, WP108_raw, WP109_raw, WP110_raw, gender_index, prosocial_contrib))
colnames(p.mat) <- c("Age", "Financial well-being", "Physical well-being", "Subjective Maths skills", "Positive Reciprocity", "Negative Reciprocity", "Altruism", "Trust", "Donated money", "Volunteered", "Helped a stranger", "Gender", "Prosocial composite")
rownames(p.mat) <- c("Age", "Financial well-being", "Physical well-being", "Subjective Maths skills", "Positive Reciprocity", "Negative Reciprocity", "Altruism", "Trust", "Donated money", "Volunteered", "Helped a stranger", "Gender", "Prosocial composite")


corrplot::corrplot(c1, method = "circle", type = "upper", order = "hclust", col = colorRampPalette(c("blue", "white", "red"))(10), p.mat = p.mat, sig.level = 0.05, addCoef.col = "black", tl.col="black", tl.srt=45, tl.cex = .75, insig = "blank", number.font = 1, number.cex = .7, diag = FALSE)

#print(p.mat)



#Look how prosociality varies with key control variables: financial, physical, and subj_math_skills
scatter_plot(df$prosocial_contrib, df$financial_wellbeing) + xlab("Prosociality") + ylab("Financial wellbeing")
scatter_plot(df$prosocial_contrib, df$physical_wellbeing) + xlab("Prosociality") + ylab("Physical wellbeing")
scatter_plot(df$prosocial_contrib, df$subj_math_skills) + xlab("Prosociality") + ylab("Subjective maths skills")

ggplot(df,aes(x=age.r,y=prosocial_contrib,col=gender)) + geom_smooth(alpha=0.2, method = lm, colour = "black") + facet_wrap(~gender) + theme_apa() + xlab("Age") + ylab("Prosociality") + geom_point(alpha = 0.1)

ggplot(df,aes(x=prosocial_contrib, col=gender)) + geom_boxplot(alpha=0.2) + theme_apa() + facet_wrap(~gender) + coord_flip() + theme_apa() + xlab("Prosociality") + 
  theme(axis.text.x=element_blank(), axis.ticks.x=element_blank())

#How does absolute prosociality vary by country?




```

## Overall preferences and behaviour models

```{r overall-models, eval=TRUE, echo=FALSE}

## NOTE: models take time to run, so are hashed out, previously run model objects are loaded in from file

# Create preference data-frame

# df.pref <- as_tibble(df) %>%
#   rename(pref_posrecip = "posrecip") %>%
#   rename(pref_altruism = "altruism") %>%
#   rename(pref_trust = "trust")
# 
# df.pref <-  df.pref %>%
#   pivot_longer(cols = starts_with("pref"), names_to = "pref", names_prefix = "pref_", values_to = "prosociality")


# Run PREFERENCES QUADRATIC model with INTERACTION TERM

# model.quad.pref <- lmer(prosociality ~ gender + financial_wellbeing + physical_wellbeing + subj_math_skills + poly(age,2)*prefs  +
#                      #(1 | id:country) +
#                      (1 | country) + 
#                      #(0 + gender | country) +
#                      (0 + financial_wellbeing | country) +
#                      (0 + physical_wellbeing | country) + 
#                      (0 + subj_math_skills | country) +
#                      (0 + age | country),
#                      data = df.pref, control = lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# save(model.lin.pref, file = paste0("output/Preferences_quadratic_model.RData"))

# Linear only PREFERENCE model

# model.lin.pref <- lmer(prosociality ~ gender + financial_wellbeing + physical_wellbeing + subj_math_skills + age*pref + (1 | country) +
#            (0 + financial_wellbeing | country) + 
#            (0 + physical_wellbeing | country) + 
#            (0 + subj_math_skills | country) +
#            (0 + age | country),
#            data = df.pref, control = lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))

# save(model.lin.pref, file = paste0("output/Preferences_linear_model.RData"))

#load pre-existing model objects for PREFERENCES

load(paste0("output/Preferences_quadratic_model.RData"))
load(paste0("output/Preferences_linear_model.RData"))

# extract model parameters

results.quad.pref <- model_parameters(model.quad.pref, effects = "fixed")

# Make and display table of PREFERENCE model QUADRATIC effects

r.quad.pref <- results.quad.pref %>%
  filter(Effects == "fixed") %>%
  select(!c(Effects)) %>%
  mutate(Parameter = str_replace_all(Parameter, pattern = ":", replacement = " * ")) %>% # for interactions
  mutate(Parameter = str_replace(Parameter, pattern = "gender1", replacement = "gender")) %>%
  mutate(Parameter = str_replace(Parameter, pattern = fixed("poly(age, 2)1"), replacement = "linear effect of age")) %>%
  mutate(Parameter = str_replace(Parameter, pattern = fixed("poly(age, 2)2"), replacement = "quadratic effect of age")) 

r.quad.pref$p[!is.na(r.quad.pref$p)] <- pvalr(r.quad.pref$p[!is.na(r.quad.pref$p)])
kable(r.quad.pref,
      align = c('l',rep('c',(ncol(r.quad.pref)-1))),
      caption = paste0("Quadratic mixed-effects model predicting prosocial preferences")) %>%
  kable_styling()

# Make and display table of PREFERENCE model LINEAR effects

results.lin.pref <- model_parameters(model.lin.pref, effects = "fixed")

r.lin.pref <- results.lin.pref %>%
  filter(Effects == "fixed") %>%
  select(!c(Effects)) %>%
  mutate(Parameter = str_replace_all(Parameter, pattern = ":", replacement = " * ")) %>% # for interactions
  mutate(Parameter = str_replace(Parameter, pattern = "gender1", replacement = "gender")) %>%
  mutate(Parameter = str_replace(Parameter, pattern = fixed("poly(age, 2)1"), replacement = "linear effect of age")) 

r.lin.pref$p[!is.na(r.lin.pref$p)] <- pvalr(r.lin.pref$p[!is.na(r.lin.pref$p)])
kable(r.lin.pref,
      align = c('l',rep('c',(ncol(r.lin.pref)-1))),
      caption = paste0("Linear mixed-effects model predicting prosocial preferences")) %>%
  kable_styling()

# Create data-frame of for BEHAVIOURS modelling

# df.behav <-  as_tibble(df) %>%
#   rename(behav_donate = "WP108") %>%
#   rename(behav_volunteer = "WP109") %>%
#   rename(behav_help = "WP110")
# 
# # Create prosociality output variable
# 
# df.behav <-  df.behav %>% pivot_longer(cols = starts_with("behav"), names_to = "behav", names_prefix = "behav_", values_to = "prosociality")
# 
# 
# # Run QUADRATIC model of BEHAVIOURS with interaction term = model.quad.behaviours
# 
# tic <- Sys.time()
# model.quad.behav <- glmer (prosociality ~ poly(age,2)*behav + gender + financial_wellbeing + physical_wellbeing + subj_math_skills +
#                              #(1 | id:country) +
#                              (1 | country) +
#                              #(0 + gender | country) +
#                              (0 + financial_wellbeing | country) +
#                              (0 + physical_wellbeing | country) +
#                              (0 + subj_math_skills | country) +
#                              (0 + age | country),
#                      data = df.behav,
#                      family = "binomial",
#                      nAGQ = 0,
#                      control = glmerControl(optimizer="nloptwrap", optCtrl=list(maxfun=2e5))
#                             )
# toc <-  Sys.time()
# toc-tic

# save(model.quad.behav, file = paste0("output/Behaviours_quadratic_model.RData"))


# # Run LINEAR model of BEHAVIOURS with interaction term = model.lin.behav

# model.lin.behav <- glmer(prosociality ~ gender + financial_wellbeing + physical_wellbeing + subj_math_skills + age*behav +
#                      #(1 | id:country) +
#                        (1 | country) +
#                        #(0 + gender | country) +
#                      (0 + financial_wellbeing | country) +
#                        (0 + physical_wellbeing | country) +
#                        (0 + subj_math_skills | country) +
#                      (0 + age | country),
#                      nAGQ = 0,
#                      data = df.behav, family = "binomial", control = glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# 
# save(model.lin.behav, file = paste0("output/Behaviours_linear_model.RData"))


load(paste0("output/Behaviours_linear_model.RData"))

load(paste0("output/Behaviours_quadratic_model.RData"))



results.quad.behav <- model_parameters(model.quad.behav, exponentiate = T, effects = "fixed")

r.quad.behav <- results.quad.behav %>%
  filter(Effects == "fixed") %>%
  select(!c(Effects)) %>%
  mutate(Parameter = str_replace_all(Parameter, pattern = ":", replacement = " * ")) %>% # for interactions
  mutate(Parameter = str_replace(Parameter, pattern = "gender1", replacement = "gender")) %>%
  mutate(Parameter = str_replace(Parameter, pattern = fixed("poly(age, 2)1"), replacement = "quadratic effect of age")) %>%
  mutate(Parameter = str_replace(Parameter, pattern = fixed("poly(age, 2)2"), replacement = "quadratic effect of age"))

r.quad.behav$p[!is.na(r.quad.behav$p)] <- pvalr(r.quad.behav$p[!is.na(r.quad.behav$p)])

kable(r.quad.behav,
      align = c('l',rep('c',(ncol(r.quad.behav)-1))),
      caption = paste0("Quadratic mixed-effects model predicting prosocial behaviours")) %>%
  kable_styling()

results.lin.behav <- model_parameters(model.lin.behav, exponentiate = T, effects = "fixed")

r.lin.behav <- results.lin.behav %>%
  filter(Effects == "fixed") %>%
  select(!c(Effects)) %>%
  mutate(Parameter = str_replace_all(Parameter, pattern = ":", replacement = " * ")) %>% # for interactions
  mutate(Parameter = str_replace(Parameter, pattern = "gender1", replacement = "gender")) %>%
  mutate(Parameter = str_replace(Parameter, pattern = fixed("poly(age, 2)1"), replacement = "linear effect of age")) 

r.lin.behav$p[!is.na(r.lin.behav$p)] <- pvalr(r.lin.behav$p[!is.na(r.lin.behav$p)])
kable(r.lin.behav,
      align = c('l',rep('c',(ncol(r.lin.behav)-1))),
      caption = paste0("Linear mixed-effects model predicting prosocial behaviours")) %>%
  kable_styling()

```

## Plotting and modelling each individual PREFERENCE

```{r pref-models-plots, eval = TRUE, echo=FALSE, message=FALSE, warning=FALSE, results='asis'}

#Overall effects

for (v in 1:length(prefs)) {

  pref <- prefs[v]
  pref.lab <- pref.labs[v]
  
  # create dataframe for modelling/plotting cycling through outcome variables one by one
  df.mod <- df %>% 
    dplyr::rename("outcome" = paste(pref)) %>% 
    drop_na(c("outcome"))
  
  # For SPEED of plotting cut out the model if required
  
  # model.quad <- lmer(outcome ~ gender + financial_wellbeing + physical_wellbeing + subj_math_skills + poly(age,2) +
  #                      (1 | country) + #(0 + gender | country) +
  #                      (0 + financial_wellbeing | country) + (0 + physical_wellbeing | country) + (0 + subj_math_skills | country) +
  #                      (0 + age | country), data = df.mod, control = lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
  # save(model.quad, file = paste0("output/",pref.lab, "_quadratic_model.RData"))
  
  load(file = paste0("output/",pref.lab, "_quadratic_model.RData"))
  
  results.quad <- model_parameters(model.quad, effects = "fixed")

  r.quad <- results.quad %>%
    filter(Effects == "fixed") %>%
    select(!c(Effects)) %>%
    # mutate(Parameter = str_replace_all(Parameter, pattern = ":", replacement = " * ")) %>% # for interactions
    mutate(Parameter = str_replace(Parameter, pattern = "gender1", replacement = "gender")) %>%
    mutate(Parameter = str_replace(Parameter, pattern = fixed("poly(age, 2)1"), replacement = "linear effect of age")) %>%
    mutate(Parameter = str_replace(Parameter, pattern = fixed("poly(age, 2)2"), replacement = "quadratic effect of age"))

  r.quad$p[!is.na(r.quad$p)] <- pvalr(r.quad$p[!is.na(r.quad$p)])
  kable(r.quad,
        align = c('l',rep('c',(ncol(r.quad)-1))),
        caption = paste0("Quadratic linear mixed-effects model predicting ", pref.lab)) %>%
  kable_styling() %>% 
  htmltools::HTML() %>% 
  print
  cat("\n")
  
  # model.lin <- lmer(outcome ~ gender + financial_wellbeing + physical_wellbeing + subj_math_skills + age +
  #                     (1 | country) + #(0 + gender | country) +
  #                     (0 + financial_wellbeing | country) + (0 + physical_wellbeing | country) + (0 + subj_math_skills | country) +
  #                     (0 + age | country), data = df.mod, control = lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
  # save(model.lin, file = paste0("output/",pref.lab, "_linear_model.RData"))
  
  # load(file = paste0("output/",pref.lab, "_linear_model.RData"))
  #   
  # results.lin <- model_parameters(model.lin, effects = "fixed")
  # 
  # r.lin <- results.lin %>%
  #   filter(Effects == "fixed") %>%
  #   select(!c(Effects)) %>%
  #   # mutate(Parameter = str_replace_all(Parameter, pattern = ":", replacement = " * ")) %>% # for interactions
  #   mutate(Parameter = str_replace(Parameter, pattern = "gender1", replacement = "gender")) %>%
  #   mutate(Parameter = str_replace(Parameter, pattern = fixed("poly(age, 2)1"), replacement = "linear effect of age")) 
  # 
  # r.lin$p[!is.na(r.lin$p)] <- pvalr(r.lin$p[!is.na(r.lin$p)])
  # kable(r.lin,
  #             align = c('l',rep('c',(ncol(r.lin)-1))),
  #             caption = paste0("Linear mixed-effects model predicting ", pref.lab))%>%
  # kable_styling() %>% 
  # htmltools::HTML() %>% 
  # print
  # cat("\n")
  
  # Plot 
  
  plot.age <- ggplot(df.mod, aes(x = age.r, y = outcome)) + 
    # geom_point(color = dotcols[1], shape = 21, fill = NA, alpha = 0.01, size = 1, show.legend = FALSE) +
    
    geom_smooth(data = df.mod, color = 'black', fill = 'black', linetype = "solid", method = "lm", formula = y ~ poly(x,2), alpha = 0.1, size = 1.5, show.legend = FALSE) + # quadratic
    
    # geom_smooth(data = df.mod, color = 'black', linetype = "dashed", method = "lm", formula = y ~ x, alpha = 0.3, size = 0.6, show.legend = FALSE, se = FALSE) +  #linear 
    
    scale_x_continuous(name = "Age") +
    scale_y_continuous(name = pref.lab) + 
    theme_classic() + 
    theme(axis.text = element_markdown(size = axtext),
          axis.title.x = element_markdown(size = axtitle),
          axis.title.y = element_markdown(size = axtitle))
  
  print(plot.age)
  
  # plot.age.continent <- plot.age + facet_wrap("continent")
  # 
  # print(plot.age.continent)
  # 
  # plot.age.gender <- plot.age +
  #   facet_grid(cols = prefs(gender))
  # 
  # print(plot.age.gender)
  # 
  # plot.age.oecd <- plot.age +
  #   facet_grid(cols = prefs(oecd))
  # 
  # print(plot.age.oecd)
  # 
  # plot.age.gdp <- plot.age +
  #   facet_grid(cols = prefs(gdp.quart))
  # 
  # print(plot.age.gdp)
  
  cat("\n")
  
}

```

## Plotting and modelling each individual BEHAVIOUR

```{r behav-models-plots, eval=TRUE, echo=FALSE, message=FALSE, warning=FALSE, results='asis'}

#Overall effects

for (v in 1:length(behavs)) {
#for (v in 1:1) {
  behav <- behavs[v]
  behav.lab <- behav.labs[v]
  
  # create dataframe for modelling/plotting cycling through outcome variables one by one
  df.mod <- df %>% 
    dplyr::rename("outcome" = paste(behav)) %>% 
    drop_na(c("outcome"))
  
  # For SPEED of plotting cut out the model if required
  
  # model.quad <- glmer(outcome ~ gender + financial_wellbeing + physical_wellbeing + subj_math_skills + poly(age,2) +
  #                      (1 | country) + #(0 + gender | country) +
  #                      (0 + financial_wellbeing | country) + (0 + physical_wellbeing | country) + (0 + subj_math_skills | country) +
  #                      (0 + age | country), data = df.mod, family = "binomial", control = glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
  
  # 
  # # save the model
  # save(model.quad, file = paste0("output/",behav.lab, "_quadratic_model.RData"))
  
  #load previously created model
  load(file = paste0("output/",behav.lab, "_quadratic_model.RData"))

  #extract results
  results.quad <- model_parameters(model.quad, effects = "fixed")

  #table results and print
  r.quad <- results.quad %>%
    filter(Effects == "fixed") %>%
    select(!c(Effects)) %>%
    # mutate(Parameter = str_replace_all(Parameter, pattern = ":", replacement = " * ")) %>% # for interactions
    mutate(Parameter = str_replace(Parameter, pattern = "gender1", replacement = "gender")) %>%
    mutate(Parameter = str_replace(Parameter, pattern = fixed("poly(age, 2)1"), replacement = "linear effect of age")) %>%
    mutate(Parameter = str_replace(Parameter, pattern = fixed("poly(age, 2)2"), replacement = "quadratic effect of age"))

  r.quad$p[!is.na(r.quad$p)] <- pvalr(r.quad$p[!is.na(r.quad$p)])
  kable(r.quad,
        align = c('l',rep('c',(ncol(r.quad)-1))),
        caption = paste0("Quadratic linear mixed-effects model predicting ", behav.lab)) %>%
  kable_styling() %>%
  htmltools::HTML() %>%
  print
  cat("\n")

  # model.lin <- glmer(outcome ~ gender + financial_wellbeing + physical_wellbeing + subj_math_skills + age +
  #                     (1 | country) + #(0 + gender | country) +
  #                     (0 + financial_wellbeing | country) + (0 + physical_wellbeing | country) + (0 + subj_math_skills | country) +
  #                     (0 + age | country), data = df.mod, family = "binomial", control = glmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
  # save(model.lin, file = paste0("output/",behav.lab, "_linear_model.RData"))

  # load(file = paste0("output/",behav.lab, "_linear_model.RData"))
  # 
  # results.lin <- model_parameters(model.lin, effects = "fixed")
  # 
  # r.lin <- results.lin %>%
  #   filter(Effects == "fixed") %>%
  #   select(!c(Effects)) %>%
  #   # mutate(Parameter = str_replace_all(Parameter, pattern = ":", replacement = " * ")) %>% # for interactions
  #   mutate(Parameter = str_replace(Parameter, pattern = "gender1", replacement = "gender")) %>%
  #   mutate(Parameter = str_replace(Parameter, pattern = fixed("poly(age, 2)1"), replacement = "linear effect of age"))
  # 
  # r.lin$p[!is.na(r.lin$p)] <- pvalr(r.lin$p[!is.na(r.lin$p)])
  # kable(r.lin,
  #             align = c('l',rep('c',(ncol(r.lin)-1))),
  #             caption = paste0("Linear mixed-effects model predicting ", behav.lab))%>%
  # kable_styling() %>%
  # htmltools::HTML() %>%
  # print
  # cat("\n")

  # Plot quadratic and linear fit
  plot.age <- ggplot(df.mod, aes(x = age.r, y = outcome)) + 
    # geom_point(color = dotcols[1], shape = 21, fill = NA, alpha = 0.01, size = 1, show.legend = FALSE) +
    geom_smooth(data = df.mod, color = 'black', fill = 'black', linetype = "solid", method = "glm", family=binomial, formula = y~poly(x,2), 
                alpha = 0.1, size = 1.5, show.legend = FALSE) + # quadratic
    scale_x_continuous(name = "Age") +
    scale_y_continuous(name = behav.lab) +
    theme_classic() + 
    theme(axis.text = element_markdown(size = axtext),
          axis.title.x = element_markdown(size = axtitle),
          axis.title.y = element_markdown(size = axtitle))
  
  print(plot.age)
  
  # plot.age.continent <- plot.age + facet_wrap("continent")
  # 
  # print(plot.age.continent)
  # 
  # plot.age.gender <- plot.age +
  #   facet_grid(cols = behavs(gender))
  # 
  # print(plot.age.gender)
  # 
  # plot.age.oecd <- plot.age +
  #   facet_grid(cols = behavs(oecd))
  # 
  # print(plot.age.oecd)
  # 
  # plot.age.gdp <- plot.age +
  #   facet_grid(cols = behavs(gdp.quart))
  # 
  # print(plot.age.gdp)
  
  cat("\n")
  
}

```

## MODEL COMPARISON

```{r model comparison, echo=FALSE, warning=FALSE}

# PREFERENCES comparison

load(file = paste0("output/Trust_quadratic_model.RData"))
model.trust.quad <- model.quad
load(file = paste0("output/Altruism_quadratic_model.RData"))
model.altruism.quad <- model.quad

AIC(model.trust.quad, model.altruism.quad)


```



## Quantification of effects in each country 

```{r country-effects, echo=FALSE, warning=FALSE, fig.align="center", fig.width=10, fig.height=8}

# cntry.list <- read.csv("data/List_countries.csv", sep = ",", header = TRUE) # list of countries
cntry.list <- df %>% 
  select(c("isocode", "country"))
cntry.list <- unique(cntry.list)

# create a dataframe with the country information and columns of NA to fill in below
countrycols <- c("isocode", "region", "n")

# "posrecip~age", "negrecip~age", "altruism~age", "trust~age", "prosocial_contrib~age",

country.results <- data.frame(cntry.list$isocode, cntry.list$country, matrix(data = NA, nrow = length(cntry.list), ncol = (length(countrycols) - 2)))
names(country.results) <- countrycols
country.results.p <- country.results

# loop over each country
for (c in country.results$isocode) {
  
  cdf <- subset(df, isocode == c) # select rows from that country
  
  #calculate basic mean for each DV per country and add to country.results
  country.results$posrecip.mean[country.results.p$isocode == c] = c(mean(cdf$posrecip, na.rm = TRUE))
  country.results$negrecip.mean[country.results.p$isocode == c] = c(mean(cdf$negrecip, na.rm = TRUE))
  country.results$altruism.mean[country.results.p$isocode == c] = c(mean(cdf$altruism, na.rm = TRUE))
  country.results$trust.mean[country.results.p$isocode == c] = c(mean(cdf$trust, na.rm = TRUE))
  country.results$prosocial_contrib.mean[country.results.p$isocode == c] =
    c(mean(cdf$prosocial_contrib, na.rm = TRUE))
  
  # standardise variables for modelling
  cdf[,c("age", "posrecip", "negrecip", "altruism", "trust", "prosocial_contrib")] <- scale(cdf[,c("age", "posrecip", "negrecip", "altruism", "trust", "prosocial_contrib")])
  
  # run linear model for each outcome & extract parameters
  cntry.p <- model_parameters(lm(posrecip ~ gender + age, data = cdf), standardize = "refit")
  cntry.n <- model_parameters(lm(negrecip ~ gender + age, data = cdf), standardize = "refit")
  cntry.a <- model_parameters(lm(altruism ~ gender + age, data = cdf), standardize = "refit")
  cntry.t <- model_parameters(lm(trust ~ gender + age, data = cdf), standardize = "refit")
  cntry.pr <- model_parameters(lm(prosocial_contrib ~ gender + age, data = cdf), standardize = "refit")
  
  #add slope coefficients to dataframe
  country.results$posrecip.age[country.results$isocode == c] = tail(cntry.p$Coefficient,1)
  country.results$negrecip.age[country.results$isocode == c] = tail(cntry.n$Coefficient,1)
  country.results$altruism.age[country.results$isocode == c] = tail(cntry.a$Coefficient,1)
  country.results$trust.age[country.results$isocode == c] = tail(cntry.t$Coefficient,1)
  country.results$prosocial_contrib.age[country.results$isocode == c] = tail(cntry.pr$Coefficient,1)
  
  #add p values (I think?)
  country.results.p$posrecip.age[country.results$isocode == c] = tail(cntry.p$p,1)
  country.results.p$negrecip.age[country.results$isocode == c] = tail(cntry.n$p,1)
  country.results.p$altruism.age[country.results$isocode == c] = tail(cntry.a$p,1)
  country.results.p$trust.age[country.results$isocode == c] = tail(cntry.t$p,1)
  country.results.p$prosocial_contrib.age[country.results$isocode == c] = tail(cntry.pr$p,1)
  #add number of observations per country
  country.results$n[country.results$isocode == c] = nrow(cdf)
  
}

# create data for map
world_map <- map_data("world") %>%
  subset(region != "Antarctica")

#map world_map countries to ISO codes
world_map$isocode <- countrycode(world_map$region, 'country.name', 'iso3c')

# # # select countries in dataset
# continents <- df %>% 
#   select("isocode", "Continent") %>% 
#   distinct()
# names(continents) <- c("isocode", "continent")
# continents$isocode <- as.character(continents$isocode)
# 
# # combine country information with results & add European countries no data collected in to show blank on map
# continents <- left_join(continents, country.results, by = "isocode") %>% 
#   add_row(region = c("Cyprus", "Czech Republic", "Estonia", "Lithuania", "Luxembourg", "Malta", "Portugal", "Belarus", "Moldova", "Slovenia", "Bosnia and Herzegovina", "Montenegro", "Kosovo", "Albania", "Bulgaria"), continent = rep("Europe", 15))
df.world <- left_join(world_map %>% select(-region), country.results, by = "isocode")


# df.europe <- subset(df.world, continent == "Europe" & region != "Russia")

# add OECD index to map dataframe
df.world$oecd <- NA

for (r in 1:nrow(df.world)) {
  if (is.na(df.world$isocode[r])) {
    df.world$oecd[r] <- 0
  } else {
    if (sum(str_detect(oecd.isocode, df.world$isocode[r])) == 0) {
      df.world$oecd[r] <- 0
    } else if (sum(str_detect(oecd.isocode, df.world$isocode[r])) == 1) {
      df.world$oecd[r] <- 1
    } else {stop('not found 1 or 0 matches')}
  }
}

df.world$oecd <- factor(df.world$oecd, levels = c(0,1), labels = c("oecd", "not oecd"))

```

# Map plots - preferences and behaviours

```{r country-plots, echo=FALSE, fig.align="center", fig.width=10, fig.height=8}

# create function plotting preferences

global_pref_map <- function(v, name) {
  ggplot(df.world, aes(long, lat, group = group)) +
  geom_polygon(aes(fill = v), color = "white", size = .1) +
  scale_fill_gradient2(low = neg.corr.col, mid = "white", high = pos.corr.col, midpoint = 0, na.value = "#ECECEC", name = expression(beta)) +
  theme_apa() +
  theme(axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank(), axis.title.x=element_blank(), axis.title.y = element_blank()) +
  draw_plot_label(name, x = -180, y = -30, hjust = 0, vjust = 0, angle = 90, size = 17, fontface = "plain")
  
}

#model outputs DV~Age
p1 <- global_pref_map(df.world$posrecip.age, "Positive Reciprocity ~ Age")
p2 <- global_pref_map(df.world$negrecip.age, "Negative Reciprocity ~ Age")
p3 <- global_pref_map(df.world$altruism.age, "Altruism ~ Age")
p4 <- global_pref_map(df.world$trust.age, "Trust ~ Age")
global_pref_map(df.world$prosocial_contrib.age, "Prosociality ~ Age")

#grid arrange
grid.arrange(p1, p2, p3, p4)

#Basic means around the world
p1 <- global_pref_map(df.world$posrecip.mean, "Positive Reciprocity")
p2 <- global_pref_map(df.world$negrecip.mean, "Negative Reciprocity")
p3 <- global_pref_map(df.world$altruism.mean, "Altruism")
p4 <- global_pref_map(df.world$trust.mean, "Trust")
global_pref_map(df.world$prosocial_contrib.mean, "Prosociality")



# Do it by facet wrap
df.long <- pivot_longer(df.world, cols = c(posrecip.mean, negrecip.mean, altruism.mean, trust.mean), names_to = "pref", values_to = "mean")
df.long$pref <- factor(df.long$pref, labels = c("Altruism", "NegativeReciprocity", "PositiveReciprocity", "Trust"))


ggplot(df.long, aes(long, lat, group = group)) +
  geom_polygon(aes(fill = mean), color = "white", size = .1) +
  scale_fill_gradient2(low = neg.corr.col, mid = "white", high = pos.corr.col, midpoint = 0, na.value = "#ECECEC", name = expression(beta)) +
  theme_apa(legend.pos = "bottom", facet.title.size = 12) +
  theme(axis.text.x=element_blank(), axis.ticks.x=element_blank(), axis.text.y=element_blank(), axis.ticks.y=element_blank(), axis.title.x=element_blank(), axis.title.y = element_blank()) +
  facet_wrap(~pref, labeller = label_value)



# plots.map <- plot_grid(world.posrecip, world.negrecip, world.altruism, world.trust,
#                        align = "v", nrow = 3, labels = "auto", label_size = axtitle-4)
# 
# print(plots.map)

```
