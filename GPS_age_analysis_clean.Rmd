---
title: "GPS_age"
author: "Jo Cutler"
date: "20/05/2021"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

options(digits = 4)

knitr::opts_knit$set(root.dir = 'D/GPS project files/R')

# load required packages and functions

require(pacman)
pacman::p_load(car,
               cowplot,
               countrycode,
               effectsize,
               factoextra,
               ggtext,
               GPArotation, 
               haven,
               Hmisc,
               irr,
               kableExtra,
               lavaan,
               lemon,
               lme4, 
               lmerTest,
               mediation,
               nFactors,
               parameters, 
               psych,
               scales,
               see,
               tidyquant,
               tidyverse
)

library(ggridges)
library(viridis)
library(hrbrthemes)


```

##Data wrangle

```{r results = "asis", echo = FALSE}

df <- read_dta("individual_new.dta") 
df<- df %>% 
  mutate(gender = factor(gender,
                      levels = c(0,1),
                      labels = c("male", "female")))
df$age.r <- df$age
df$age <- scale(df$age)

resolution <- 300
plotW <- 4
plotH <- 4

axtext <- 16
axtitle <- 20
dotcols <- c("#A363D9")
pos.corr.col <- "#CA4640" 
neg.corr.col <-  "#00A7DD"

vars <- c("prosocial_contrib", "posrecip", "negrecip", "altruism", "trust")
var.labs <- c("Prosociality", "Positive reciprocity", "Negative reciprocity", "Altruism", "Trust")

#add continent names to df
df$continent <- countrycode(df$country, 'country.name', 'region')

#Add gni data
gni <- readxl::read_xlsx("GNI.xlsx") %>%
rename("isocode" = "Country Code") %>%
rename("gni" = "2018GNI") %>%
mutate(gni = scale(gni)) %>%
mutate(IncomeGroup = factor(IncomeGroup, levels = c("Low income", "Lower middle income", "Upper middle income", "High income"), ordered = T))

df <- left_join(df, gni, by = "isocode")

# OECD allocation (from Gender file)
world.bank <- read.csv("Data_Extract_From_World_Development_Indicators/5f01a212-b834-4098-aa44-7c7bdc81428f_Data.csv", na.strings = "..", fileEncoding = 'UTF-8-BOM') %>% # NB. fileEncoding prevents i.. on 1st column name
  rename("isocode" = "Country.Code")

gdp <- world.bank %>%
  subset(Series.Code == "NY.GDP.PCAP.CD") %>% 
  rename("gdp" = "X2012..YR2012.") 

gdp <- semi_join(x = gdp, y = df, by = "isocode") %>%
  mutate(gdp.quart = ntile(gdp, 4)) %>%
  mutate(gdp = scale(gdp))

le <- world.bank %>% 
  subset(str_detect(Series.Name, "Life expectancy at birth")) %>% 
  rename("life.exp" = "X2012..YR2012.") %>% 
  pivot_wider(id_cols = c("Country.Name", "isocode"), names_from = "Series.Name", values_from = "life.exp")
  
colnames(le) <- gsub("Life expectancy at birth, ", "le.", colnames(le))
colnames(le) <- gsub(" ", ".", colnames(le))

df <- left_join(df, gdp, by = "isocode")
df <- left_join(df, le, by = "isocode")

# OECD or not?
oecd <- c("Austria", "Australia", "Belgium", "Canada", "Chile", "Colombia", "Costa Rica", "Czech Republic", "Denmark", "Estonia", "Finland", "France", "Germany", "Greece", "Hungary", "Iceland", "Ireland", "Israel", "Italy", "Japan", "Korea", "Latvia", "Lithuania", "Luxembourg", "Mexico", "the Netherlands", "New Zealand", "Norway", "Poland", "Portugal", "Slovak Republic", "Slovenia", "Spain", "Sweden", "Switzerland", "Turkey", "the United Kingdom", "United States") # from https://www.oecd.org/newsroom/oecd-welcomes-costa-rica-as-its-38th-member.htm

oecd.code <- countrycode(oecd, 'country.name', 'iso3c')

# add adjusted age and OECD index to main dataframe

df$age.adj <- NA
df$oecd <- NA

for (r in 1:nrow(df)) {
  if (is.na(df$isocode[r])) {
    df$oecd[r] <- 0
  } else {
    if (sum(str_detect(oecd.code, df$isocode[r])) == 0) {
      df$oecd[r] <- 0
    } else if (sum(str_detect(oecd.code, df$isocode[r])) == 1) {
      df$oecd[r] <- 1
    } else {stop('not found 1 or 0 matches')}
  }

  if(df$gender[r] == "male") {
    df$age.adj[r] <- df$age.r[r] / df$`le.male.(years)`[r]
  } else if (df$gender[r] == "female") {
    df$age.adj[r] <- df$age.r[r] / df$`le.female.(years)`[r]
  }
}

df$oecd <- factor(df$oecd, levels = c(1,0), labels = c("oecd", "not oecd"))

df$age.adj.z <- scale(df$age.adj)



```

## PCA
```{r}

#without weighting, with neg reciprocity
df.dropna <- df %>% drop_na(c("posrecip", "negrecip", "altruism", "trust")) %>% select(posrecip, negrecip, altruism, trust)

cor(df.dropna[,c("posrecip", "negrecip", "altruism", "trust")])

dat.pca <- prcomp(df.dropna[,c("posrecip", "negrecip", "altruism", "trust")], scale = TRUE)

summary(dat.pca)

fviz_eig(dat.pca)

fviz_pca_var(dat.pca,
             col.var = "contrib", # Color by contributions to the PC
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE     # Avoid text overlapping
             )

get_eigenvalue(dat.pca)


#without weighting, without neg reciprocity

cor(df.dropna[,c("posrecip", "altruism", "trust")])

dat.pca <- prcomp(df.dropna[,c("posrecip", "altruism", "trust")], scale = TRUE)

summary(dat.pca)

fviz_eig(dat.pca)

fviz_pca_var(dat.pca,
             col.var = "contrib", # Color by contributions to the PC
             gradient.cols = c("#00AFBB", "#E7B800", "#FC4E07"),
             repel = TRUE     # Avoid text overlapping
             )

get_eigenvalue(dat.pca)

#loadings of variable on each component
dat.pca$rotation

dat.var <- get_pca_var(dat.pca)
dat.var$contrib        # Contributions to the Principal Component



# Create new prosociality composite based on CONTRIBUTION weighting
df$prosocial_contrib <- scale(dat.var$contrib["posrecip",1]*df$posrecip + 
                     dat.var$contrib["altruism",1]*df$altruism + 
                     dat.var$contrib["trust",1]*df$trust)

# Create new prosociality composite based on COMPONENT LOADING weighting
df$prosocial_load <- scale(dat.pca$rotation["posrecip",1]*df$posrecip + 
                     dat.pca$rotation["altruism",1]*df$altruism + 
                     dat.pca$rotation["trust",1]*df$trust) * -1

#create weighted prosociliaty measures
df$prosocial_wgt_c <- df$prosocial_contrib * df$wgt
df$prosocial_wgt_l <- df$prosocial_load * df$wgt



# # Exploratory Factor analysis
# 
# # Determine Number of Factors to Extract with Neg Recip
# 
# ev <- eigen(cor(df.dropna)) # get eigenvalues
# 
# ap <- parallel(subject=nrow(df.dropna),var=ncol(df.dropna),
#   rep=100,cent=.05)
# 
# nS <- nScree(x=ev$values, aparallel=ap$eigen$qevpea)
# 
# plotnScree(nS)
# 

# # Determine Number of Factors to Extract WITHOUT Neg Recip
# library(nFactors)
# 
# ev <- eigen(cor(df.dropna[,c("posrecip", "altruism", "trust")])) # get eigenvalues
# 
# ap <- parallel(subject=nrow(df.dropna[,c("posrecip", "altruism", "trust")]),var=ncol(df.dropna[,c("posrecip", "altruism", "trust")]),
#   rep=100,cent=.05)
# 
# nS <- nScree(x=ev$values, aparallel=ap$eigen$qevpea)
# 
# plotnScree(nS)
# 
# 
# 
# # Maximum Likelihood Factor Analysis
# # entering raw data and extracting 1 factor for 4 variables
# # with varimax rotation
# fit <- factanal(df.dropna, 1, rotation="varimax")
# print(fit, digits=2, cutoff=.3, sort=TRUE)
# 
# # entering raw data and extracting 1 factor for 3 variables (WITHOUT Neg Recip)
# # with varimax rotation
# fit <- factanal(df.dropna[,c("posrecip", "altruism", "trust")], 1, rotation="varimax")
# print(fit, digits=2, cutoff=.3, sort=TRUE)






```


##Plotting and modelling main effects
```{r, message=FALSE, warning=FALSE, echo = FALSE}

#This is the code if we want to run SAMPLES

# for (v in 1:length(vars)) {
#   
#   var <- vars[v]
#   var.lab <- var.labs[v]
#   
#   df.mod <- df %>% 
#     dplyr::rename("outcome" = paste(var)) %>% 
#     drop_na(c("outcome","age"))
#   
#   for (j in 1:5) {
#     df.sample <- sample_n(df.mod, 5000)
#   
#   model.quad <- lmer(outcome ~ gender + poly(age,2) + (1 | country) + (0 + age | country), data = df.sample, control = lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
#   
#   results.quad <- model_parameters(model.quad, ci_method = "satterthwaite", standardize = "refit")
# 
#   # table.age <- kable(results.quad) %>% kable_styling()
#   # print(table.age)
#   print(results.quad)
#   
#   plot.age <- ggplot(df.sample, aes(x = age.r, y = outcome)) + 
#     geom_point(color = dotcols[1], shape = 21, fill = NA, alpha = 0.01, size = 1, show.legend = FALSE) + 
#     geom_smooth(color = dotcols[1], fill = dotcols[1], linetype = "solid", method = "lm", formula = y ~ poly(x,2), alpha = 0.3, size = 0.75, show.legend = FALSE) + 
#     scale_x_continuous(name = "Age") +
#     scale_y_continuous(name = var.lab) + 
#     theme_classic() + 
#     theme(axis.text = element_markdown(size = axtext),
#           axis.title.x = element_markdown(size = axtitle),
#           axis.title.y = element_markdown(size = axtitle))
#   
#   print(plot.age)
#   cat("\n")
#   }
# }

#Overall effects

age_cutoff = 73

for (v in 1:length(vars)) {
# for (v in 1:1) {
  
  var <- vars[v]
  var.lab <- var.labs[v]
  
  # create dataframe for modelling/plotting cycling through outcome variables one by one
  df.mod <- df %>% 
    dplyr::rename("outcome" = paste(var)) %>% 
    drop_na(c("outcome","age"))
  
  # create second dataframe cutting out all people over 73 years (95th percentile)
  df.mod_new <- df.mod
  df.mod_new$age.r[df.mod_new$age.r > age_cutoff] <- NA
  df.mod_new$age[df.mod_new$age.r > age_cutoff] <- NA
  
  df.mod_new <- df.mod_new %>% drop_na(age.r)
  
  df.mod_new$subj_math_skills <- scale(df.mod_new$subj_math_skills)
   
  # For SPEED of plotting cut out the model if required
  
# model.quad <- lmer(outcome ~ gender +  subj_math_skills + gni + poly(age,2) + (1 | country) + (0 + subj_math_skills | country) + (0 + age | country), data = df.mod_new, control = lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# 
# results.quad <- model_parameters(model.quad, ci_method = "satterthwaite", standardize = "refit")
# 
# print(paste(var.lab, " QUADRATIC MODEL RESULTS"))
# 
# print(results.quad)

# model.lin <- lmer(outcome ~ gender +  subj_math_skills + gni + age + (1 | country) + (0 + subj_math_skills | country) + (0 + age | country), data = df.mod_new, control = lmerControl(optimizer="bobyqa", optCtrl=list(maxfun=2e5)))
# 
# results.lin <- model_parameters(model.lin, ci_method = "satterthwaite", standardize = "refit")
# 
# print(paste(var.lab, " LINEAR MODEL RESULTS"))
# 
# print(results.lin)
  

  # Plot quadratic and linear fit
    plot.age <- ggplot(df.mod, aes(x = age.r, y = outcome)) + 
    # geom_point(color = dotcols[1], shape = 21, fill = NA, alpha = 0.01, size = 1, show.legend = FALSE) +
      
    # geom_smooth(color = dotcols[1], fill = dotcols[1], linetype = "solid", method = "lm", formula = y ~ poly(x,2), alpha = 0.3, size = 0.75, show.legend = FALSE) + #quadratic all ages
      
    # geom_smooth(color = dotcols[1], linetype = "solid", method = "lm", formula = y ~ x, alpha = 0.3, size = 0.6, show.legend = FALSE, se = FALSE) + #linear all ages
      
    geom_smooth(data = df.mod_new, color = 'black', fill = 'black', linetype = "solid", method = "lm", formula = y ~ poly(x,2), alpha = 0.1, size = 1.5, show.legend = FALSE) + # quadratic to 73
      
    # geom_smooth(data = df.mod_new, color = 'black', linetype = "dashed", method = "lm", formula = y ~ x, alpha = 0.3, size = 0.6, show.legend = FALSE, se = FALSE) +  #linear to 73
      
      # geom_smooth(color = "blue", se = FALSE, size = 0.6) + # smoothed
      
    scale_x_continuous(name = "Age") +
    scale_y_continuous(name = var.lab) + 
      ylim(-0.3, 0.2) +
    theme_classic() + 
    theme(axis.text = element_markdown(size = axtext),
          axis.title.x = element_markdown(size = axtitle),
          axis.title.y = element_markdown(size = axtitle))
  
  print(plot.age)
  
  plot.age.continent <- plot.age + facet_wrap("continent")
  
  print(plot.age.continent)
  
  plot.age.gender <- plot.age +
    facet_grid(cols = vars(gender))
  
  print(plot.age.gender)
  
  plot.age.oecd <- plot.age +
    facet_grid(cols = vars(oecd))
  
  print(plot.age.oecd)
  
  plot.age.gdp <- plot.age +
    facet_grid(cols = vars(gdp.quart))
  
  print(plot.age.gdp)
  
  
  cat("\n")
}



```


## Quantification of effects in each country 

```{r fig.align="center", fig.width=10, fig.height=8}

# cntry.list <- read.csv("List_countries.csv", sep = ",", header = TRUE) # list of countries
cntry.list <- df %>% 
  select(c("isocode", "country"))
cntry.list <- unique(cntry.list)

# create a dataframe with the country information and columns of NA to fill in below
countrycols <- c("code", "region", "posrecip", "negrecip", "altruism", "trust", "prosocial_contrib", "n")
# country.results <- data.frame(cntry.list$ISO3, cntry.list$Map.Name, matrix(data = NA, nrow = nrow(cntry.list), ncol = (length(countrycols) - 2)))
country.results <- data.frame(cntry.list$isocode, cntry.list$country, matrix(data = NA, nrow = length(cntry.list), ncol = (length(countrycols) - 2)))
names(country.results) <- countrycols
country.results.p <- country.results[,1:6]

# loop over each country
for (c in country.results$code) {
  
  cdf <- subset(df, isocode == c) # select rows from that country
  
  # standardise variables
  cdf[,c("age", "posrecip", "negrecip", "altruism", "trust", "prosocial_contrib")] <- scale(cdf[,c("age", "posrecip", "negrecip", "altruism", "trust", "prosocial_contrib")])
  
  # run linear model for each outcome & extract parameters
  cntry.p <- model_parameters(lm(posrecip ~ gender + age, data = cdf), standardize = "refit")
  cntry.n <- model_parameters(lm(negrecip ~ gender + age, data = cdf), standardize = "refit")
  cntry.a <- model_parameters(lm(altruism ~ gender + age, data = cdf), standardize = "refit")
  cntry.t <- model_parameters(lm(trust ~ gender + age, data = cdf), standardize = "refit")
  cntry.pr <- model_parameters(lm(prosocial_contrib ~ gender + age, data = cdf), standardize = "refit")
  country.results[country.results$code == c, 3:7] = c(tail(cntry.p$Coefficient,1),
                                                      tail(cntry.n$Coefficient,1), 
                                                      tail(cntry.a$Coefficient,1),
                                                      tail(cntry.t$Coefficient,1),
                                                      tail(cntry.pr$Coefficient,1))
  country.results.p[country.results.p$code == c, 3:7] = c(tail(cntry.p$p,1),
                                                          tail(cntry.n$p,1), 
                                                          tail(cntry.a$p,1), 
                                                          tail(cntry.t$p,1),
                                                          tail(cntry.pr$p,1))
  country.results$n[country.results$code == c] = nrow(cdf)

}

country.results.all <- country.results

# # select countries with more than 450 participants
# country.results.p <- country.results.p[country.results$n > 450, ]
# country.results <- country.results[country.results$n > 450, ]
# 
# # find countries with significant effects for each outcome
# age.sig.d <- country.results[country.results.p$distancing < 0.05,]
# age.notsig.d <- country.results[country.results.p$distancing >= 0.05,]
# age.sig.n <- country.results[country.results.p$negrecip < 0.05,]
# age.notsig.n <- country.results[country.results.p$negrecip >= 0.05,]
# age.sig.i <- country.results[country.results.p$internegrecip < 0.05,]
# age.notsig.i <- country.results[country.results.p$internegrecip >= 0.05,]
# age.sig.b <- country.results[country.results.p$bias < 0.05,]
# age.notsig.b <- country.results[country.results.p$bias >= 0.05,]
# 
# country.results$region <- as.character(country.results$region)
# country.results$code <- as.character(country.results$code)

# create data for map
world_map <- map_data("world") %>%
  subset(region != "Antarctica")

#map world_map countries to ISO codes
world_map$code <- countrycode(world_map$region, 'country.name', 'iso3c')

# # # select countries in dataset
# continents <- df %>% 
#   select("isocode", "Continent") %>% 
#   distinct()
# names(continents) <- c("code", "continent")
# continents$code <- as.character(continents$code)
# 
# # combine country information with results & add European countries no data collected in to show blank on map
# continents <- left_join(continents, country.results, by = "code") %>% 
#   add_row(region = c("Cyprus", "Czech Republic", "Estonia", "Lithuania", "Luxembourg", "Malta", "Portugal", "Belarus", "Moldova", "Slovenia", "Bosnia and Herzegovina", "Montenegro", "Kosovo", "Albania", "Bulgaria"), continent = rep("Europe", 15))
df.world <- left_join(world_map %>% select(-region), country.results, by = "code")
# df.europe <- subset(df.world, continent == "Europe" & region != "Russia")

# add OECD index to map dataframe - GENDER file code
df.world$oecd <- NA

for (r in 1:nrow(df.world)) {
  if (is.na(df.world$code[r])) {
    df.world$oecd[r] <- 0
  } else {
    if (sum(str_detect(oecd.code, df.world$code[r])) == 0) {
      df.world$oecd[r] <- 0
    } else if (sum(str_detect(oecd.code, df.world$code[r])) == 1) {
      df.world$oecd[r] <- 1
    } else {stop('not found 1 or 0 matches')}
  }
}

df.world$oecd <- factor(df.world$oecd, levels = c(0,1), labels = c("oecd", "not oecd"))

#END OF GENDER FILE CODE

```


# Create plots
```{r fig.align="center", fig.width=10, fig.height=8}

#plot age vs prosociality
#Moving average smoothing
df %>% group_by(age.r, continent) %>% filter(age.r <= 70) %>% summarise(across(prosocial_contrib, mean, na.rm= TRUE)) %>%  ggplot(aes(age.r, prosocial_contrib)) + geom_ma(aes(color = continent, group = continent), ma_fun = SMA, n=5, linetype = "solid", size = 1.5) + theme_bw()

#Loess smoothing
plot.contrib <- df %>% group_by(age.r, continent) %>% filter(age.r <= 70) %>% summarise(across(prosocial_contrib, mean, na.rm= TRUE)) %>%  ggplot(aes(age.r, prosocial_contrib)) + geom_smooth(aes(color = continent, group = continent, fill = continent), linetype = "solid", size = 1.5) + theme_bw()

#Plot Prosociality using COMPONENT LOADING from PCA rather than percentage CONTRIBUTION
plot.load <- df %>% group_by(age.r, continent) %>% filter(age.r <= 70) %>% summarise(across(prosocial_load, mean, na.rm= TRUE)) %>%  ggplot(aes(age.r, prosocial_load)) + geom_smooth(aes(color = continent, group = continent, fill = continent), linetype = "solid", size = 1.5) + theme_bw()

plot_grid(plot.contrib, plot.load)

#plot age vs prosociality WEIGHTED
df %>% group_by(age.r, continent) %>% filter(age.r <= 70) %>% summarise(across(prosocial_wgt_c, mean, na.rm= TRUE)) %>%  ggplot(aes(age.r, prosocial_wgt_c)) + geom_ma(aes(color = continent, group = continent), ma_fun = SMA, n=5, linetype = "solid", size = 1.5) + theme_bw()

# create a map figure for each outcome (distancing, negrecip giving, and internegrecip giving)

world.posrecip <- ggplot(df.world, aes(long, lat, group = group)) +
  geom_polygon(aes(fill = posrecip), color = "white", size = .1) +
   scale_fill_gradient2(low = neg.corr.col, mid = "white", high = pos.corr.col, midpoint = 0, na.value = "#ECECEC", name = expression(beta)) +
  theme_void() +
  draw_plot_label("Positive reciprocity", x = -180, y = -10, hjust = 0, vjust = 0, angle = 90, size = axtitle, fontface = "plain")

# europe.posrecip <- ggplot(df.europe, aes(long, lat, group = group)) +
#   geom_polygon(aes(fill = distancing), color = "white", size = .1) +
#   scale_fill_gradientn(colours = col2(200), limits = c(-.28, .28), breaks = c(-0.2, 0, 0.2), na.value = "#ECECEC", name = expression(beta)) +
#   theme_void() +
#   guides(fill = guide_colorbar(title.hjust = 0.05)) + 
#   theme(legend.text = element_text(size = axtext),
#         legend.title = element_text(size = axtitle))

world.negrecip <- ggplot(df.world, aes(long, lat, group = group)) +
  geom_polygon(aes(fill = negrecip), color = "white", size = .1) +
  scale_fill_gradient2(low = neg.corr.col, mid = "white", high = pos.corr.col, midpoint = 0, na.value = "#ECECEC", name = expression(beta)) +
  theme_void() +
  draw_plot_label("Negative reciprocity", x = -180, y = -20, hjust = 0, vjust = 0, angle = 90, size = axtitle, fontface = "plain")

# europe.negrecip <- ggplot(df.europe, aes(long, lat, group = group)) +
#   geom_polygon(aes(fill = negrecip), color = "white", size = .1) +
#   scale_fill_gradientn(colours = col2(200), limits = c(-.28, .28), breaks = c(-0.2, 0, 0.2), na.value = "#ECECEC", name = expression(beta)) +
#   theme_void() +
#   guides(fill = guide_colorbar(title.hjust = 0.05)) + 
#   theme(legend.text = element_text(size = axtext),
#         legend.title = element_text(size = axtitle))

world.altruism <- ggplot(df.world, aes(long, lat, group = group)) +
  geom_polygon(aes(fill = altruism), color = "white", size = .1) +
    scale_fill_gradient2(low = neg.corr.col, mid = "white", high = pos.corr.col, midpoint = 0, na.value = "#ECECEC", name = expression(beta)) +
  theme_void() +
  draw_plot_label("Altruism", x = -180, y = -35, hjust = 0, vjust = 0, angle = 90, size = axtitle, fontface = "plain")

# europe.inter <- ggplot(df.europe, aes(long, lat, group = group)) +
#   geom_polygon(aes(fill = altruism), color = "white", size = .1) +
#   scale_fill_gradientn(colours = col2(200), limits = c(-.28, .28), breaks = c(-0.2, 0, 0.2), na.value = "#ECECEC", name = expression(beta)) +
#   theme_void() +
#   guides(fill = guide_colorbar(title.hjust = 0.05)) + 
#   theme(legend.text = element_text(size = axtext),
#         legend.title = element_text(size = axtitle))

world.trust <- ggplot(df.world, aes(long, lat, group = group)) +
  geom_polygon(aes(fill = trust), color = "white", size = .1) +
    scale_fill_gradient2(low = neg.corr.col, mid = "white", high = pos.corr.col, midpoint = 0, na.value = "#ECECEC", name = expression(beta)) +
  theme_void() +
  draw_plot_label("Trust", x = -180, y = -35, hjust = 0, vjust = 0, angle = 90, size = axtitle, fontface = "plain")


world.prosocial <- ggplot(df.world, aes(long, lat, group = group)) +
  geom_polygon(aes(fill = prosocial_contrib), color = "white", size = .1) +
    scale_fill_gradient2(low = neg.corr.col, mid = "white", high = pos.corr.col, midpoint = 0, na.value = "#ECECEC", name = expression(beta)) +
  theme_void() +
  draw_plot_label("Prosociality", x = -180, y = -35, hjust = 0, vjust = 0, angle = 90, size = axtitle, fontface = "plain")

print(world.prosocial)

# europe.trust

plots.map <- plot_grid(world.posrecip, world.negrecip, world.altruism, world.trust, world.prosocial,
                        align = "v", nrow = 3, labels = c("a", "", "b", "", "c", ""), label_size = axtitle-4)

print(plots.map)

```
